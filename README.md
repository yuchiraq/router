# Go Reverse Proxy с административной панелью

Этот проект — Go‑сервис, который сочетает обратный прокси и веб‑панель управления маршрутизацией, статистикой и логами. Он принимает входящие HTTP/HTTPS‑запросы, сопоставляет их с правилами в `rules.json` и проксирует трафик на внутренние сервисы. Кроме того, он содержит панель администратора для управления правилами, режимом обслуживания и просмотра метрик в реальном времени.

## Что внутри и как это работает

### Общая архитектура

1. **Хранилище правил**
   - `storage.Storage` читает и пишет JSON‑файл `rules.json`, где хранятся правила маршрутизации и флаг режима обслуживания.
   - `storage.RuleStore` держит правила в памяти, предоставляет методы для добавления/удаления/поиска правил, содержит флаг `MaintenanceMode` и периодически проверяет доступность целевых сервисов.

2. **Обратный прокси**
   - `proxy.Proxy` реализует `http.Handler` и для каждого запроса ищет правило по `Host`.
   - При включенном режиме обслуживания возвращает страницу `maintenance.html` со статусом `503`.
   - При отсутствии правила возвращает `404`.
   - При наличии правила — проксирует на целевой сервис через `httputil.NewSingleHostReverseProxy` и обновляет статистику запросов.

3. **Админ‑панель**
   - `panel.Handler` обслуживает HTML‑шаблоны и REST‑эндпоинты добавления/удаления правил.
   - Использует базовую аутентификацию (если заданы логин/пароль в окружении).
   - Отдает статистику в JSON и стримит логи по WebSocket.

4. **Статистика и логи**
   - `stats.Stats` собирает метрики: количество запросов по доменам, использование памяти и CPU.
   - `logstream.Broadcaster` вещает лог‑сообщения всем подключенным клиентам, а также хранит последние 100 записей.

### Точки входа (две конфигурации запуска)

В проекте есть две точки входа, с разной конфигурацией серверов:

#### `main.go` (боевой режим с TLS/Let’s Encrypt)

- **Порты:**
  - HTTP: `:80` (ACME challenge + редирект/прокси через `autocert`)
  - HTTPS: `:443`
  - Админ‑панель: `:8162`
- **TLS:** автоматические сертификаты через `golang.org/x/crypto/acme/autocert`.
- **Аутентификация панели:** `ADMIN_USER` / `ADMIN_PASS`.
- **Логи:** пишутся в `stderr` и в WebSocket‑стрим.
- **Период метрик памяти:** каждые 5 секунд.

#### `cmd/main.go` (единый сервер на 8080)

- **Порт:** `:8080`.
- **Маршрутизация:**
  - Панель доступна по `/panel/*`.
  - Прокси обрабатывает все остальные пути.
- **Аутентификация панели:** `ROUTER_USERNAME` / `ROUTER_PASSWORD`.
- **Период метрик памяти/CPU:** каждые 3 секунды.

## Правила маршрутизации (`rules.json`)

Правила хранятся в JSON‑файле `rules.json` в формате:

```json
{
  "rules": {
    "example.com": {
      "target": "localhost:3000"
    },
    "api.example.com": {
      "target": "10.0.0.15:8080"
    }
  },
  "maintenanceMode": false
}
```

- Ключом выступает домен (`Host`), который приходит в запросе.
- `target` — адрес внутреннего сервиса (без схемы, например `localhost:3000`).
- Флаг `maintenanceMode` управляет страницей обслуживания.

`RuleStore` хранит еще и служебные поля (последний доступ, флаг доступности сервиса), но они не сериализуются в файл.

## Административная панель

Панель предоставляет:

- **Главная (`/`)** — список правил, форма добавления, переключатель режима обслуживания.
- **Статистика (`/stats`)** — графики памяти, CPU и запросов (Chart.js).
- **Логи (`/ws/logs` или `/ws`)** — поток логов в реальном времени через WebSocket.

### Эндпоинты панели

| Метод | Путь | Назначение |
|---|---|---|
| GET | `/` | список правил, переключатель режима обслуживания |
| POST | `/` | включение/выключение режима обслуживания |
| POST | `/add` | добавить правило (`host`, `target`) |
| POST | `/remove` | удалить правило (`host`) |
| GET | `/stats` | HTML‑страница с графиками |
| GET | `/stats/data` | JSON‑данные для графиков |
| GET | `/ws/logs` | WebSocket для логов |

> В варианте запуска через `cmd/main.go` все эти маршруты находятся под префиксом `/panel` (например, `/panel/stats`).

## Метрики и мониторинг

- **Память** — собирается через `gopsutil/mem` и отображается на графике как процент и абсолютное значение.
- **CPU** — собирается через `gopsutil/cpu`.
- **Запросы** — сгруппированы по доменам и отображаются как график по последним 24 часам.

## Проверка здоровья сервисов

`RuleStore` каждые 60 секунд пытается подключиться к целевому сервису (`net.DialTimeout`). Если адрес не содержит порт, отметка сервиса как «down» сохраняется в памяти (это используется для статуса в UI/логике, но не записывается в JSON).

## Зависимости

- `golang.org/x/crypto/acme/autocert` — автоматическое получение TLS‑сертификатов.
- `github.com/gorilla/websocket` — WebSocket‑стрим логов.
- `github.com/shirou/gopsutil` — сбор системных метрик.

## Структура проекта

```
.
├── main.go                      # Запуск с TLS/Let’s Encrypt
├── cmd/main.go                  # Альтернативный запуск на :8080
├── internal/
│   ├── config/                  # Конфигурация через env‑переменные
│   ├── logstream/               # Бродкастер логов для WebSocket
│   ├── panel/                   # Обработчики и шаблоны панели
│   ├── proxy/                   # Обратный прокси
│   ├── stats/                   # Сбор и выдача метрик
│   └── storage/                 # Хранилище и RuleStore
├── rules.json                   # Локальное хранилище правил (создается автоматически)
└── README.md
```

## Быстрый старт

### Вариант 1: TLS + порты 80/443

1. Убедитесь, что у вас есть домен, указывающий на этот сервер.
2. Установите переменные окружения (опционально для базовой авторизации панели):

   ```bash
   export ADMIN_USER=admin
   export ADMIN_PASS=secret
   ```

3. Запустите:

   ```bash
   go run main.go
   ```

### Вариант 2: локальный запуск на :8080

1. Установите переменные окружения (опционально):

   ```bash
   export ROUTER_USERNAME=admin
   export ROUTER_PASSWORD=secret
   ```

2. Запустите:

   ```bash
   go run cmd/main.go
   ```

## Поведение прокси

- **TLS‑режим**: HTTPS на `:443`, HTTP на `:80` используется для ACME‑челленджа.
- **Поиск правила**: домен сопоставляется по `Host` заголовку (например, `example.com`).
- **Проксирование**: заголовки `X-Forwarded-Host` и `Host` обновляются перед передачей запроса целевому сервису.
- **Режим обслуживания**: возвращается 503 + страница обслуживания.

---

Если хотите расширить поведение (например, добавить авторизацию, rate‑limiting или кэширование), основные точки расширения находятся в `internal/proxy`, `internal/panel` и `internal/storage`.
